// Originally generated by quicktype (https://quicktype.io/), then manually cleaned up

using CatalogueScanner.Core.Serialisation;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace CatalogueScanner.SaleFinder.Dto.SaleFinder
{
    /// <summary>
    /// Returned from the SaleFinder Catalogue SVG Data request:
    /// https://embed.salefinder.com.au/catalogue/svgData/{saleId}/?format=json
    /// </summary>
    public partial class SaleFinderCatalogue
    {
        public string? Content { get; set; }
        public string? Breadcrumb { get; set; }
        public string? AreaName { get; set; }
        public string? SaleDescription { get; set; }
        public string? SaleName { get; set; }
        public string? YoutubeId { get; set; }

        [JsonConverter(typeof(SaleFinderDateTimeOffsetConverter))]
        public DateTimeOffset PublishDate { get; set; }

        [JsonConverter(typeof(SaleFinderDateTimeOffsetConverter))]
        public DateTimeOffset StartDate { get; set; }

        [JsonConverter(typeof(SaleFinderDateTimeOffsetConverter))]
        public DateTimeOffset EndDate { get; set; }

        [JsonInclude]
        [JsonPropertyName("catalogue")]
        public ICollection<Page> Pages { get; internal set; } = new List<Page>();
    }

    [JsonConverter(typeof(PageConverter))]
    public partial class Page
    {
        [JsonIgnore]
        public IList<Item> Items { get; internal set; } = new List<Item>();

        [JsonPropertyName("imagefile")]
        public string? ImageFile { get; set; }

        [JsonPropertyName("image_width")]
        public double? ImageWidth { get; set; }

        [JsonPropertyName("image_height")]
        public double? ImageHeight { get; set; }

        [JsonPropertyName("animatedimagefile")]
        public string? AnimatedImageFile { get; set; }

        [JsonPropertyName("pagetab")]
        public string? PageTab { get; set; }

        [JsonPropertyName("pagedesc")]
        public string? PageDesc { get; set; }
    }

    internal partial class PageWithExtensionData : Page
    {
        [JsonExtensionData]
        public Dictionary<string, JsonElement> ExtensionData { get; set; } = new();
    }

    public partial class Item
    {
        public string? VideoId { get; set; }
        public Shape Shape { get; set; }

        [JsonInclude]
        [JsonConverter(typeof(SaleFinderJsonCollectionItemConverter<long, ICollection<long>, ExponentInt64Converter>))]
        public ICollection<long> Coords { get; internal set; } = new List<long>();

        public long? ItemId { get; set; }
        public string? Href { get; set; }

        [JsonPropertyName("SKU")]
        public string? Sku { get; set; }

        [JsonConverter(typeof(ExponentInt64Converter))]
        public long? SystemId { get; set; }

        public object? ExtraId { get; set; }
        public object? Extra2Id { get; set; }

        [JsonPropertyName("extraURL")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Design", "CA1056:Uri properties should not be strings", Justification = "SaleFinder may not output valid URIs for this property")]
        public string? ExtraUrl { get; set; }

        [JsonPropertyName("extraURLText")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Design", "CA1056:Uri properties should not be strings", Justification = "This property probably isn't a URI")]
        public string? ExtraUrlText { get; set; }

        [JsonPropertyName("itemURL")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Design", "CA1056:Uri properties should not be strings", Justification = "SaleFinder does not output full URIs for this property")]
        public string? ItemUrl { get; set; }

        public string? ItemName { get; set; }

        [JsonConverter(typeof(ExponentInt64Converter))]
        public long? SkuCount { get; set; }

        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }

    [JsonConverter(typeof(JsonStringEnumMemberConverter))]
    public enum Shape
    {
        Rectangle
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1812:AvoidUninstantiatedInternalClasses", Justification = "Instantiated by System.Text.Json using reflection")]
    internal class PageConverter : JsonConverter<Page>
    {
        public override Page Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            #region null checks
            if (typeToConvert is null)
            {
                throw new ArgumentNullException(nameof(typeToConvert));
            }

            if (options is null)
            {
                throw new ArgumentNullException(nameof(options));
            }
            #endregion

            var context = new SaleFinderInternalSerializerContext(new JsonSerializerOptions(options));

            // Create a PageWithExtensionData instance, populate the standard (non-numeric) property names from the JSON
            // and store the overflow in the ExtensionData property
            var page = JsonSerializer.Deserialize(ref reader, context.PageWithExtensionData);

            if (page is null)
            {
                throw new JsonException("page instance is null");
            }

            // Add the numeric property names to the Items collection
            foreach (var keyValuePair in page.ExtensionData)
            {
                if (int.TryParse(keyValuePair.Key, out var index))
                {
                    var item = keyValuePair.Value.Deserialize(context.Item);

                    if (item is null)
                    {
                        throw new JsonException($"item instance at index {index} is null");
                    }

                    page.Items.Insert(index, item);
                }
            }

            // Create a normal Page instance from the deserialised data
            return new Page
            {
                ImageFile = page.ImageFile,
                ImageHeight = page.ImageHeight,
                ImageWidth = page.ImageWidth,
                Items = page.Items,
            };
        }

        public override void Write(Utf8JsonWriter writer, Page value, JsonSerializerOptions options)
        {
            #region null checks
            if (writer is null)
            {
                throw new ArgumentNullException(nameof(writer));
            }

            if (value is null)
            {
                throw new ArgumentNullException(nameof(value));
            }

            if (options is null)
            {
                throw new ArgumentNullException(nameof(options));
            }
            #endregion

            // Create a JsonNode and populate the standard (non-numeric) property names
            var pageNode = JsonSerializer.SerializeToNode(value, options);

            if (pageNode is null)
            {
                throw new JsonException($"null returned from {nameof(JsonSerializer.SerializeToNode)}");
            }

            // Add the values from the Items collection as numeric property names
            for (var i = 0; i < value.Items.Count; i++)
            {
                pageNode[i.ToString("d", NumberFormatInfo.InvariantInfo)] = JsonSerializer.SerializeToNode(value.Items[i], options);
            }

            // Serialise the JsonNode to JSON
            pageNode.WriteTo(writer);
        }
    }

    /// <summary>
    /// Converter that can parse numbers in scientific notation/exponent format (e.g. 3.07446E+18) as <see cref="long"/> values, in addition to the standard integer/floating-point formats.
    /// 
    /// Note that the scientific notation/floating-point formats are only supported in the range of <see cref="double"/>.
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1812:AvoidUninstantiatedInternalClasses", Justification = "Instantiated by System.Text.Json using reflection")]
    internal class ExponentInt64Converter : JsonConverter<long?>
    {
        public override long? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            #region null checks
            if (typeToConvert is null)
            {
                throw new ArgumentNullException(nameof(typeToConvert));
            }

            if (options is null)
            {
                throw new ArgumentNullException(nameof(options));
            }
            #endregion

            switch (reader.TokenType)
            {
                case JsonTokenType.Number:
                    return reader.GetInt64();

                case JsonTokenType.String:
                    var stringValue = reader.GetString();

                    if (long.TryParse(stringValue, out var longValue))
                    {
                        return longValue;
                    }

                    if (double.TryParse(stringValue, out var doubleValue))
                    {
                        return (long)doubleValue;
                    }

                    break;
            }

            throw new JsonException($"Error reading {typeof(long).Name} from {typeof(Utf8JsonReader).Name}. Current item is not a number or numeric string: {reader.TokenType}");
        }

        public override void Write(Utf8JsonWriter writer, long? value, JsonSerializerOptions options)
        {
            #region null checks
            if (writer is null)
            {
                throw new ArgumentNullException(nameof(writer));
            }

            if (value is null)
            {
                throw new ArgumentNullException(nameof(value));
            }

            if (options is null)
            {
                throw new ArgumentNullException(nameof(options));
            }
            #endregion

            if (value.HasValue)
            {
                writer.WriteNumberValue(value.Value);
            }
            else
            {
                writer.WriteNullValue();
            }
        }
    }

    // Adapted from JsonMicrosoftDateTimeOffsetConverter in Macross.Json.Extensions
    internal class SaleFinderDateTimeOffsetConverter : JsonConverterFactory
    {
        public override bool CanConvert(Type typeToConvert)
        {
            #region null checks
            if (typeToConvert is null)
            {
                throw new ArgumentNullException(nameof(typeToConvert));
            }
            #endregion

            return typeToConvert == typeof(DateTimeOffset)
                || (typeToConvert.IsGenericType && IsNullableDateTimeOffset(typeToConvert));
        }

        public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
        {
            #region null checks
            if (typeToConvert is null)
            {
                throw new ArgumentNullException(nameof(typeToConvert));
            }

            if (options is null)
            {
                throw new ArgumentNullException(nameof(options));
            }
            #endregion

            return typeToConvert.IsGenericType
                ? new JsonNullableDateTimeOffsetConverter()
                : new JsonStandardDateTimeOffsetConverter();
        }

        private static bool IsNullableDateTimeOffset(Type typeToConvert)
        {
            var underlyingType = Nullable.GetUnderlyingType(typeToConvert);

            return underlyingType != null && underlyingType == typeof(DateTimeOffset);
        }

        private class JsonStandardDateTimeOffsetConverter : JsonDateTimeOffsetConverter<DateTimeOffset>
        {
            public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                => ReadDateTimeOffset(ref reader);

            public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
                => WriteDateTimeOffset(writer, value);
        }

        private class JsonNullableDateTimeOffsetConverter : JsonDateTimeOffsetConverter<DateTimeOffset?>
        {
            public override DateTimeOffset? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                => ReadDateTimeOffset(ref reader);

            public override void Write(Utf8JsonWriter writer, DateTimeOffset? value, JsonSerializerOptions options)
                => WriteDateTimeOffset(writer, value!.Value);
        }

        private abstract class JsonDateTimeOffsetConverter<T> : JsonConverter<T>
        {
            /// <summary>
            /// The date time format used by SaleFinder.
            /// </summary>
            private const string DateTimeFormat = "yyyy/MM/dd HH:mm:ss";

            public static DateTimeOffset ReadDateTimeOffset(ref Utf8JsonReader reader)
            {
                if (reader.TokenType != JsonTokenType.String)
                {
                    throw new JsonException($"Error reading {typeof(T).Name} from {typeof(Utf8JsonReader).Name}. Current item is not a string: {reader.TokenType}");
                }

                var formatted = reader.GetString()!;

                return DateTimeOffset.ParseExact(formatted, DateTimeFormat, CultureInfo.InvariantCulture);
            }

            public static void WriteDateTimeOffset(Utf8JsonWriter writer, DateTimeOffset value) =>
                writer.WriteStringValue(value.ToString(DateTimeFormat, CultureInfo.InvariantCulture));
        }
    }

    public class SaleFinderJsonCollectionItemConverter<TData, TCollection, TConverter> : BaseJsonCollectionItemConverter<TData, TCollection, TConverter>
        where TCollection : IEnumerable<TData>
        where TConverter : JsonConverter, new()
    {
        protected override JsonSerializerContext? GetJsonSerializerContext(JsonSerializerOptions options) => new SaleFinderSerializerContext(options);
    }
}
